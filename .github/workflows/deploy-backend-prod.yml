name: Deploy Backend Prod

on:
  push:
    branches:
      - prod

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: PROD
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install cloudflared, sshpass and jq
        run: |
          sudo apt-get update && sudo apt-get install -y sshpass jq
          
          # Check if Cloudflare is needed (reading from appropriate env.json)
          USE_CLOUDFLARE_SSH=$(grep USE_CLOUDFLARE_SSH .github/env-config/prod/env.json | awk -F'"' '{print $4}')
          if [ "$USE_CLOUDFLARE_SSH" = "true" ]; then
            echo "Installing cloudflared..."
            curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
            sudo dpkg -i cloudflared.deb
            rm cloudflared.deb
          fi

      - name: Generate .env.prod
        id: gen_env
        env:
          ALL_SECRETS: ${{ toJson(secrets) }}
          ALL_VARS: ${{ toJson(vars) }}
        run: |
          # Load public variables from repository JSON
          jq -r 'to_entries | .[] | "\(.key)=\(.value)"' .github/env-config/prod/env.json > .env.prod
          
          # Load secrets and env vars from GitHub Environments using mapping JSON
          jq -n --argjson secrets "$ALL_SECRETS" --argjson vars "$ALL_VARS" --argjson mapping "$(cat .github/env-config/prod/secrets.json)" '
            $mapping | to_entries | .[] | 
            .key as $k | .value as $v |
            ($secrets[$v] // $vars[$v]) as $val |
            if $val != null then "\($k)=\($val)" else empty end
          ' -r >> .env.prod
          
          # Handle optional bulk secret
          if [ ! -z "${{ secrets.BE_ENV_SECRET }}" ]; then
            echo "${{ secrets.BE_ENV_SECRET }}" >> .env.prod
          fi

      - name: Run Deploy Script
        run: |
          # Use Environment-level secrets (prioritize specific first, then generic)
          SSH_PASS="${{ secrets.SSH_PASSWORD_PROD }}"
          [ -z "$SSH_PASS" ] && SSH_PASS="${{ secrets.SSH_PASSWORD }}"
          
          SSH_USER="${{ secrets.SSH_USER_PROD }}"
          [ -z "$SSH_USER" ] && SSH_USER="${{ secrets.SSH_USER }}"
          
          SSH_HOST="${{ secrets.SSH_HOST_PROD }}"
          [ -z "$SSH_HOST" ] && SSH_HOST="${{ secrets.SSH_HOST }}"
          
          DEPLOY_PATH="${{ secrets.DEPLOY_PATH_PROD }}"
          [ -z "$DEPLOY_PATH" ] && DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"

          USE_CLOUDFLARE_SSH=$(grep USE_CLOUDFLARE_SSH .github/env-config/prod/env.json | awk -F'"' '{print $4}')
          
          if [ "$USE_CLOUDFLARE_SSH" = "true" ]; then
             SSH_OPTS="-o StrictHostKeyChecking=no -o 'ProxyCommand=cloudflared access ssh --hostname %h'"
          else
             SSH_OPTS="-o StrictHostKeyChecking=no"
          fi

          sshpass -p "$SSH_PASS" ssh $SSH_OPTS $SSH_USER@$SSH_HOST "
            set -e
            export PATH=\$PATH:/usr/bin:/usr/local/bin:/snap/bin
            
            # Auto-install Docker and Docker Compose if missing
            if ! command -v docker &> /dev/null || ! docker compose version &> /dev/null; then
              echo 'Docker or Docker Compose plugin not found. Installing...'
              
              # Clean up potentially malformed previous attempts
              echo '$SSH_PASS' | sudo -S rm -f /etc/apt/sources.list.d/archive_uri*docker*
              echo '$SSH_PASS' | sudo -S rm -f /etc/apt/sources.list.d/docker.list
              
              echo '$SSH_PASS' | sudo -S apt-get update -y
              echo '$SSH_PASS' | sudo -S apt-get install -y ca-certificates curl gnupg lsb-release
              
              # Add Docker's official GPG key the modern way
              echo '$SSH_PASS' | sudo -S install -m 0755 -d /etc/apt/keyrings
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /tmp/docker.gpg
              echo '$SSH_PASS' | sudo -S gpg --dearmor -o /etc/apt/keyrings/docker.gpg --yes /tmp/docker.gpg
              echo '$SSH_PASS' | sudo -S chmod a+r /etc/apt/keyrings/docker.gpg
              rm /tmp/docker.gpg
              
              # Set up the repository
              echo \"deb [arch=\\\$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\$(lsb_release -cs) stable\" | \
              echo '$SSH_PASS' | sudo -S tee /etc/apt/sources.list.d/docker.list > /dev/null
              
              echo '$SSH_PASS' | sudo -S apt-get update -y
              
              echo 'Installing Docker components...'
              echo '$SSH_PASS' | sudo -S apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin || {
                echo 'Standard install failed, trying convenience script...'
                curl -fsSL https://get.docker.com -o get-docker.sh
                echo '$SSH_PASS' | sudo -S sh get-docker.sh
              }
              
              # Legacy standalone docker-compose for compatibility
              if ! command -v docker-compose &> /dev/null; then
                echo 'Installing standalone Docker Compose v2.2.3...'
                echo '$SSH_PASS' | sudo -S curl -L \"https://github.com/docker/compose/releases/download/v2.2.3/docker-compose-\$(uname -s)-\$(uname -m)\" -o /usr/local/bin/docker-compose
                echo '$SSH_PASS' | sudo -S chmod +x /usr/local/bin/docker-compose
              fi
              
              echo '$SSH_PASS' | sudo -S usermod -aG docker $SSH_USER
              echo '$SSH_PASS' | sudo -S systemctl start docker || true
            fi
            
            # Ensure deployment directory exists and is a git repository
            if [ ! -d \"$DEPLOY_PATH/.git\" ]; then
              echo \"Repository not found at $DEPLOY_PATH. Cloning...\"
              echo '$SSH_PASS' | sudo -S mkdir -p $DEPLOY_PATH
              echo '$SSH_PASS' | sudo -S chown -R $SSH_USER:$SSH_USER $DEPLOY_PATH
              git clone -b prod https://github.com/kimlong8892/goouty_backend_api.git $DEPLOY_PATH
            fi

            cd $DEPLOY_PATH
            echo '$SSH_PASS' | sudo -S chown -R $SSH_USER:$SSH_USER .
            git fetch origin prod
            git reset --hard origin/prod
          "
          
          # Upload .env.prod
          sshpass -p "$SSH_PASS" scp $SSH_OPTS .env.prod $SSH_USER@$SSH_HOST:$DEPLOY_PATH/.env.prod
          
          # Run the deploy script
          sshpass -p "$SSH_PASS" ssh $SSH_OPTS $SSH_USER@$SSH_HOST "
            set -e
            export PATH=\$PATH:/usr/bin:/usr/local/bin:/snap/bin
            cd $DEPLOY_PATH
            echo 'Deploying Backend Prod...'
            chmod +x deploy_cicd_prod.sh
            ./deploy_cicd_prod.sh
            
            echo 'Waiting for containers to start...'
            sleep 10
            
            echo 'Running database migrations...'
            docker compose -p goouty-api-prod exec -T app npx prisma migrate deploy
            
            # Run seed only if database is empty
            echo 'Checking if database needs seeding...'
            docker compose -p goouty-api-prod exec -T app npm run seed:conditional
            
            echo '--- Container Logs ---'
            docker compose -p goouty-api-prod logs --tail=50
          "
